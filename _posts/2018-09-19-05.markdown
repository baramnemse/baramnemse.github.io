---
layout: post
title:  "마이크로서비스 - 데이터 조인하기"
date:   2018-9-19
description: 마이크로서비스에서는 데이터 저장영역이 독립적이기 때문에 Join을 쓸수가 없습니다. 이를 해결하기 위한 방법이 두 가지 있습니다.
---
# 데이터 저장의 독립성
이 부분은 마이크로서비스로 전환할때 왜 데이터 베이스를 서비스 오너십에 따라서 나눠야하는지 설명하는 부분입니다. 필요 없다면 다음 파트로 넘어가도 됩니다.

Monolithic 아키텍처에서는 하나의 거대한 DB를 사용합니다. 서비스 - DB 연결이 Many to One 구조입니다. 하지만 마이크로서비스에서는 One to One 구조입니다. 다양한 서비스들이 하나의 DB에 연결되면 다음 두가지의 문제 현상이 발생합니다.

1. DB를 바꾸는것이 너무 고통스럽다.
2. 서비스를 안쓰고 DB를 쓴다.

전통적인 RDBMS는 데이터의 안전한 저장을 목표로하기 때문에 업데이트가 빈번하거나 랜덤 읽기가 많을 경우에는 부적합합니다. 이 때문에 서바스 환경에 따라서 RDBMS와 NoSQL을 같이 사용합니다. 하지만 많은 서비스들이 하나의 DB를 쓸경우 서비스 중에 1%정도만 바꾸고 싶어도 나머지 99%를 신경써야하는 문제가 발생합니다. 주문과 상품 서비스가 있지만 /orders, /items에 GET요청 보다는 해당 테이블에 Select를 합니다. 서비스에 GET요청을 하여 데이터를 받을 경우 스키마가 달라져도 GET요청에 API 버전 정보를 추가하여 대응할 수 있지만 직접 Select하는 경우는 해당 테이블에 의존관계에 있는 모든 서비스에서 예외처리와 변경이 필요합니다. DB를 물리적으로 나누는것이 가장 좋으나 운영비용 때문에 어렵다면 최소한 Foreign Key같은 Constraint 라도 제거 하세요. Constraint를 쓸경우 테이블 간에 의존성이 강하게 생깁니다. 하나의 거대한 RDBMS를 사용한다면 다음과 같은 단계적 접근을 추천합니다.

1. Foreign Key 제거
2. Select 대신 해당 서비스 통해 조회, Select > Http Get
3. DB 물리적 분리

2번까지만 달성하더라도 서비스가 굉장히 유연해지나 DB 물리적 분리까지 달성하면 더 굉장해집니다.

# Join in Client Application
주문-상품의 조인 데이터가 필요하면 주문 조회, 상품 조회후에 어플리케이션에서 조인하자

# Materialize The View
주문, 상품의 변경을 리스팅하여 주문-상품뷰를 실시간으로 업데이트
