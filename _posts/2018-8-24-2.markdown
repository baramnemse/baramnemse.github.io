---
layout: post
title:  "마이크로서비스 시대의 클래스 설계원칙"
date:   2018-8-24
description: 모듈 > 클래스 > 마이크로서비스로 바뀌는 패러다임에서 클래스 설계원칙이 마이크로서비스에는 어떻게 적용되는지 알아봅시다.
---

<p class="intro"><span class="dropcap">P</span>rinciple 는 소프트웨어 디자인에서 소프트웨어를 바라보는 뷰와 구현 방법을 제시하는 중요한 개념입니다. Monolithtic 아키텍처에서는 한곳에 수많은 소스코드가 모이기 때문에 클래스 설계원칙이 매우 중요합니다. 마이크로서비스 시대에서도 이 개념은 여전히 적용됩니다. 단위가 클래스에서 마이크로서비스로 변경된것뿐입니다.</p>

# 단일책임의 원칙: Single Responsibility Principle
객체는 오직 하나의 책임을 가져야 한다. 객체는 오직 하나의 변경의 이유만을 가져야 한다.

마이크로서비스는 하나의 대상을 다루게 설계해야합니다. API 콜 방식에서는 지키기 어려운 원칙입니다.

https://baramnemse.github.io/blog/1/

 저의 이전 블로그 내용을 보면 가입자에서 쿠폰을 발행하는 시나리오가 나오는데 이벤트 기간이 끝나면 API 콜 방식에서는 계정 서비스를 수정해야합니다. 이벤트 기간이 끝났나도 계정 서비스를 수정해서는 안됩니다. 이벤트는 이벤트 서비스가 담당하고 계정 서비스는 계정에 대한 서비스만 해야합니다.

# 인터페이스 분리의 원칙: Interface Segregation Principle
클라이언트에서 사용하지 않는 메서드는 사용해선 안된다. 그러므로 인터페이스를 다시 작게 나누어 만든다.

# 개방폐쇄의 원칙: Open Close Principle
객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다는 원칙이다. 즉, 객체 기능의 확장을 허용하고 스스로의 변경은 피해야 한다.

# 의존성역전의 원칙: Dependency Inversion Principle
추상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다는 원칙으로서, 일반적으로 객체지향의 인터페이스를 통해서 이 원칙을 준수할 수 있게 된다. (상대적으로 고수준인) 클라이언트는 저수준의 클래스에서 추상화한 인터페이스만을 바라보기 때문에, 이 인터페이스를 구현한 클래스는 클라이언트에 어떤 변경도 없이 얼마든지 나중에 교체될 수 있다. (전략 패턴을 떠올리면 된다)

# 리스코브 치환의 원칙: The Liskov Substitution Principle
자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙이다. 즉 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다는 것. 상속의 본질인데, 이를 지키지 않으면 부모 클래스 본래의 의미가 변해서 is a 관계가 망가져 다형성을 지킬 수 없게 된다.

# 참고자료

https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99
